#!/usr/bin/perl -w

########################################################################
# twuewand, a truerand algorithm for generating entropy
# Copyright (C) 2011 Ryan Finnie <ryan@finnie.org>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA.
########################################################################

# Intended usage:
#   twuewand $(cat /proc/sys/kernel/random/poolsize) >/dev/urandom

my $VERSION = '1.0';

use warnings;
use strict;
use Getopt::Long;
use Pod::Usage;
use Time::HiRes qw/alarm/;
use Module::Load::Conditional qw/can_load/;
# Digest::SHA may be loaded below
# Digest::MD5 may be loaded below

my(
  $opt_help,
  $opt_quiet,
  $opt_interval,
  $opt_nowhiten,
);

$opt_interval = 0.004;

my($optresult) = GetOptions(
  'help|?' => \$opt_help,
  'quiet|q' => \$opt_quiet,
  'interval|i=f' => \$opt_interval,
  'no-whiten|w' => \$opt_nowhiten,
);

if((scalar @ARGV == 0) || $opt_help) {
  print STDERR "twuewand version $VERSION\n";
  print STDERR "Copyright (C) 2011 Ryan Finnie <ryan\@finnie.org>\n";
  print STDERR "\n";
  pod2usage(2);
}

# A digest function object and size of its output.  If whitening is 
# disabled, no digest will be used, and instead bytes will output one 
# at a time.
my($digestobj);
my($digestsize) = 1;
unless($opt_nowhiten) {
  if(can_load(modules => {'Digest::SHA' => 4.3.0})) {
    require Digest::SHA;
    $digestobj = \&Digest::SHA::sha512;
    $digestsize = 64;
  } else {
    unless($opt_quiet) { print STDERR "Warning: Cannot find Digest::SHA; falling back to MD5.\n"; }
    require Digest::MD5;
    $digestobj = \&Digest::MD5::md5;
    $digestsize = 16;
  }
}

# Number of bytes to generate
my($reqbytes) = $ARGV[0] + 0;
# Used for formatting the status output
my($fmtlen) = length($reqbytes);

# Data stored (up to $digestsize bytes) before whitening/outputting
my($outbuff) = "";
# The length of $outbuff
my($outbufflen) = 0;
# Number of bytes left to generate (refreshed when $outbuff is flushed)
my($outleft) = $reqbytes;

# Signal handlers
$SIG{ALRM} = "tick";

# These variables must be global since the alarm handler relies on them
my($statebit, $outbitscnt, $outbits);
for(my($reqbytesi) = 0; $reqbytesi < $reqbytes; $reqbytesi++) {
  $outbitscnt = 0;
  $outbits = 0;
  # Set the alarm
  $statebit = 0; alarm($opt_interval);

  # Flip a state bit until a full byte is built.
  # Note: the alarm handler will reset $statebit to 0 after an output bit
  # is generated.
  while($outbitscnt < 8) {
    $statebit ^= 1;
  }

  # Once we have a full byte, add it to the buffer
  $outbuff .= chr($outbits);
  $outbufflen++;
  unless($opt_quiet) { printf STDERR "%sGenerated: %" . $fmtlen . "i/%i (%3i%%)", chr(13), ($reqbytesi + 1), $reqbytes, (($reqbytesi + 1) / $reqbytes * 100); }

  # If we have $digestsize bytes, run them through a digest and output the result
  if($outbufflen == $digestsize) {
    if($opt_nowhiten) {
      print $outbuff;
    } else {
      print &$digestobj($outbuff);
    }
    $outbuff = "";
    $outbufflen = 0;
    $outleft -= $digestsize;
  }

}

# If there are any bytes left in the buffer, run them through a digest,
# truncate and output the result
if($outleft > 0) {
  if($opt_nowhiten) {
    print $outbuff;
  } else {
    print substr(&$digestobj($outbuff), 0, $outleft);
  }
  $outbuff = "";
  $outbufflen = 0;
  $outleft = 0;
}

unless($opt_quiet) { print STDERR "\n"; }
exit;

sub tick {
  # We have a random bit!
  # Shift and add the new bit to the working byte
  $outbits = ($outbits << 1) + $statebit;
  $outbitscnt++;
  # If we still need more bits for this byte, schedule a new alarm
  if($outbitscnt < 8) {
    $statebit = 0; alarm($opt_interval);
  }
}

__END__

=head1 NAME

twuewand - A truerand algorithm for generating entropy

=head1 SYNOPSIS

B<twuewand> S<[ B<options> ]> I<bytes>

=head1 DESCRIPTION

B<twuewand> is software that creates hardware-generated random data.  
It accomplishes this by exploiting the fact that the CPU clock and the 
RTC (real-time clock) are physically separate, and that time and work 
are not linked.  twuewand schedules a SIGALRM for a short time in the 
future (0.004 seconds by default), then begins flipping a bit as fast 
as possible.  When the alarm is delivered, the bit's state is recorded.  
This process is performed multiple times until the number of desired 
bytes have been generated.  The data is then (by default) run through a 
cryptographic hash digest (default SHA512, but will fall back to MD5 if 
Digest::SHA is not available) to "whiten" and normalize the data before 
being output.

twuewand is based on the truerand algorithm, by D. P. Mitchell in 1995.  
The output of twuewand is not designed to be used as random data 
directly (but could be in a pinch), but is for seeding a PRNG, when a 
saved PRNG state is not available (on a LiveCD or diskless workstation, 
for example).  An example use in Linux is:

    twuewand $(cat /proc/sys/kernel/random/poolsize) >/dev/urandom

Seeding /dev/urandom will seed both the urandom and random.

=head1 OPTIONS

=over

=item B<-i> interval (B<--interval>)

The alarm interval to set for each bit collection round, in seconds.  
Default is 0.004 seconds.  This is approximately how long each bit will 
take to compute; a full byte will take at least 8 times as long.  A 
higher or lower value will affect entropy distribution, and setting 
this too low could cause all data to become zero.

=item B<-q> (B<--quiet>)

Do not print status information to STDERR.

=item B<-w> (B<--no-whiten>)

Do not whiten the output by hashing with a cryptographic hash digest.  
Instead, output the raw bytes.  Running the data through a digest will 
help correct bias by evening distribution.  Systems such as Linux's 
seed input will also correct for bias, but doing it ourselves 
additionally shouldn't hurt.  It also helps with bias when using this 
program as a direct RNG.

=back

=head1 BUGS

Unknown at this time.

=head1 SEE ALSO

=over

=item /dev/random - Wikipedia

http://en.wikipedia.org/wiki//dev/random

=item Hardware random number generator - Wikipedia

http://en.wikipedia.org/wiki/Hardware_random_number_generator

=item Analysis of the Linux Random Number Generator

http://eprint.iacr.org/2006/086.pdf

=item Re: `Random' seed.

http://www.atomicfrog.com/knowledge/security/misc/truerand.c

=back

=head1 AUTHOR

B<twuewand> was written by Ryan Finnie <ryan@finnie.org>.

=cut
